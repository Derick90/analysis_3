# Creating the leadership data frame
# manager <- c(1, 2, 3, 4, 5)
# date <- c("10/24/08", "10/28/08", "10/1/08", "10/12/08", "5/1/09")
# country <- c("US", "US", "UK", "UK", "UK")
# gender <- c("M", "F", "F", "M", "F")
# age <- c(32, 45, 25, 39, 99)
# q1 <- c(5, 3, 3, 3, 2)
# q2 <- c(4, 5, 5, 3, 2)
# q3 <- c(5, 2, 5, 4, 1)
# q4 <- c(5, 5, 5, NA, 2)
# q5 <- c(5, 5, 2, NA, 1)

leadership <- data.frame(manager, date, country, gender, age, q1, q2, q3, q4, q5, stringsAsFactors=FALSE)


manager <- c(1, 2, 3, 4, 5)

date <- c("10/24/08", "10/28/08", "10/1/08", "10/12/08", "5/1/09")

country <- c("US", "US", "UK", "UK", "UK")

gender <- c("M", "F", "F", "M", "F")

age <- c(32, 45, 25, 39, 99)

q2 <- c(4, 5, 5, 3, 2)

q3 <- c(5, 2, 5, 4, 1)

q4 <- c(5, 5, 5, NA, 2)

q5 <- c(5, 5, 2, NA, 1)

q1 <- c(5, 3, 3, 3, 2)

# Exercise 1
# Let’s say that you want to recode the ages of the managers in our leadership dataset from the continuous variable age to the categorical variable agecat (Young, Middle Aged, Elder).

# a) First, recode the value 99 for age to missing with NA.
age

age[age == 99] <- NA

# b) Change the variables manager to managerID and date to testDate.
manager
date

managerID <- manager

testDate <- date

# c) The date is coded as a character variable in mm/dd/yy format. Please replace it in the data frame as a date variable.

date <- as.Date(date, format = "%m/%d/%y ")
date

leadership

# d) Create a new dataset containing rows sorted:
#   • from youngest manager to oldest manager.
# • into female followed by male, and youngest to oldest within each gender.
# • by gender, and then from oldest to youngest manager within each gender.


leadership
leadership1 <- leadership[order(age),]
leadership1

leadership1 <- leadership[order(gender),]

leadership1


leadership1 <- leadership[order(gender, age),]
leadership1

leadership1 <- leadership[order(gender, -age),]
leadership1

# e) Select variables q1, q2, q3, q4, and q5 from the leadership data frame and save them to the data frame newdata

newdata <- data.frame(q1, q2, q3, q4, q5)


# Exercise 2

# Selecting or excluding observations (rows) is typically a key aspect of successful data preparation and analysis.
# a) Select all men over 30 from the leadership dataframe.


leadership1 <- leadership[which(age > 30 & gender== "M"),]
leadership1


# b) Select all rows that have a value of age greater than or equal to 35 or age less than 24 and keep the variables q1 through q4.

leadership1 <- subset(leadership, age >= 35 | age < 24,
                      select = c(q1, q2, q3, q4))
leadership1


# c) Select all men over the age of 25 and keep variables gender through q4 (gender, q4, and all columns between them). Hint: the colon operator from:to provides all variables in a data frame between the from variable and the to variable, inclusive.


leadership1 <- subset(leadership, gender == "M" & age > 25,
                      select = c(gender:q4))
leadership1


# d) Take a random sample of size 3 from the leadership dataset without replacemen.


leadership1 <- leadership[sample(1:nrow(leadership), 3, replace = FALSE),]
leadership1


# e) Transpose the leadership dataframe so that the column names (variable names) become
# the row names.

leadership1 <- t(leadership)
leadership1

# f) Aggregate the mtcars data by number of cylinders (cyl) and gears (gear), returning means on each of the numeric variables. The mtcars data is part of the R package (run help(mtcars) to view its description

help(mtcars)
attach(mtcars)

aggregate(mtcars, by= list(cyl,gear), FUN = mean, na.rm=TRUE)


# Exercise 3
# Consider the provided “state_income” data which contains hypothetical income generated by US states from year 2002 to 2015. For this exercise, please use use the package Dplyr. For a cheatsheet visit https://www.rstudio.com/wp-content/uploads/2015/02/data-wranglingcheatsheet.pdf or for direct access in Rstudio, please click Help -> Cheatsheets -> Data Transformation with Dplyr

# a) Suppose you are asked to select only a few variables. Selects variables “Index”, columns from “State” to “Y2008”. Hint: use select() function.
library(dplyr)
getwd()
state_income <- read.delim("state_income.txt", sep = ",")
state_income

state_income1 <- state_income %>% select(Index, State:Y2008)
head(state_income1)


# b) Select (call this mydata2) and then drop variables (call this mydata3) starts with ‘Y’. Hint: The starts_with() function is used to select variables starts with an alphabet. Adding a negative sign before starts_with() implies dropping the variables starts with the alphabet.

head(state_income |> select(starts_with("Y")))


# c) Suppose you need to subset the data. Please filter rows and retain only those values in which Index is equal to A. Hint: use filter() function.

state_income1 %>% filter(Index == "A")

# d) Calculate the mean and median for the variable Y2015. Hint: use summarise() function.

state_income %>% summarise ( Mean = mean(Y2015),
                             Median= median(Y2015))


# e) Calculating count and mean of variables Y2011 and Y2012 by variable Index.

state_income %>%
  group_by(Index)%>%
  summarise(Count= n(),
            Mean_2011 = mean(Y2011, na.rm=TRUE),
            Mean_2012 = mean(Y2012, na.rm=TRUE))




# Exercise 4:

# combining datasets using join() function Generate the two datasets by running the following codes:
df1 = data.frame(ID = c(1, 2, 3, 4, 5),
                 w = c('a', 'b', 'c', 'd', 'e'),
                 x = c(1, 1, 0, 0, 1),
                 y=rnorm(5),
                 z=letters[1:5])

df2 = data.frame(ID = c(1, 7, 3, 6, 8),
                 a = c('z', 'b', 'k', 'd', 'l'),
                 b = c(1, 2, 3, 0, 4),
                 c =rnorm(5),
                 d =letters[2:6])
# a) Merge df1 and df2 with ID as common variable (primary key). Hint: use inner_join

inner_join(df1,df2)

# b) Select all rows from the left table (df1), even if there are no matches in the right tablen(df2). Hint: use left_join

left_join(df1,df2)


# c) Include rows of df1 that match df2 but only keep the columns from df1. Hint: use semi_join()

semi_join(df1,df2)


# d) Select the opposite of what was selected in c) above. Hint: use anti_join()


anti_join(df1,df2)

 


